digraph "" {
AccessControl -> Context [ label="1" ];
AccessControl -> IAccessControl [ label="2" ];
AccessControl -> ERC165 [ label="3" ];
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

IAccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkOwner()</TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

IERC1967[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1967</B></TD></TR></TABLE> >];

IERC2981 -> IERC165;
IERC2981[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC2981</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    royaltyInfo(uint256,uint256)</TD></TR></TABLE> >];

IERC5267[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC5267</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    eip712Domain()</TD></TR></TABLE> >];

IERC1822Proxiable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1822Proxiable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    proxiableUUID()</TD></TR></TABLE> >];

ERC1967Upgrade -> IERC1967;
ERC1967Upgrade[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1967Upgrade</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getImplementation()</TD></TR><TR><TD align="left">    _setImplementation(address)</TD></TR><TR><TD align="left">    _upgradeTo(address)</TD></TR><TR><TD align="left">    _upgradeToAndCall(address,bytes,bool)</TD></TR><TR><TD align="left">    _upgradeToAndCallUUPS(address,bytes,bool)</TD></TR><TR><TD align="left">    _getAdmin()</TD></TR><TR><TD align="left">    _setAdmin(address)</TD></TR><TR><TD align="left">    _changeAdmin(address)</TD></TR><TR><TD align="left">    _getBeacon()</TD></TR><TR><TD align="left">    _setBeacon(address)</TD></TR><TR><TD align="left">    _upgradeBeaconToAndCall(address,bytes,bool)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _ROLLBACK_SLOT</TD></TR><TR><TD align="left">    _IMPLEMENTATION_SLOT</TD></TR><TR><TD align="left">    _ADMIN_SLOT</TD></TR><TR><TD align="left">    _BEACON_SLOT</TD></TR></TABLE> >];

Proxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Proxy</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _delegate(address)</TD></TR><TR><TD align="left">    _implementation()</TD></TR><TR><TD align="left">    _fallback()</TD></TR><TR><TD align="left">    _beforeFallback()</TD></TR></TABLE> >];

BeaconProxy -> Proxy [ label="1" ];
BeaconProxy -> ERC1967Upgrade [ label="2" ];
BeaconProxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BeaconProxy</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _beacon()</TD></TR><TR><TD align="left"><font color="#FFA500">    _implementation()</font></TD></TR><TR><TD align="left">    _setBeacon(address,bytes)</TD></TR></TABLE> >];

IBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    implementation()</TD></TR></TABLE> >];

UpgradeableBeacon -> IBeacon [ label="1" ];
UpgradeableBeacon -> Ownable [ label="2" ];
UpgradeableBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UpgradeableBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    implementation()</font></TD></TR><TR><TD align="left">    upgradeTo(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setImplementation(address)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _implementation</TD></TR></TABLE> >];

ERC1155 -> Context [ label="1" ];
ERC1155 -> ERC165 [ label="2" ];
ERC1155 -> IERC1155 [ label="3" ];
ERC1155 -> IERC1155MetadataURI [ label="4" ];
ERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    uri(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOfBatch(address[],uint256[])</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setApprovalForAll(address,bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeTransferFrom(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _setURI(string)</TD></TR><TR><TD align="left">    _mint(address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _mintBatch(address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _burn(address,uint256,uint256)</TD></TR><TR><TD align="left">    _burnBatch(address,uint256[],uint256[])</TD></TR><TR><TD align="left">    _setApprovalForAll(address,address,bool)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _doSafeTransferAcceptanceCheck(address,address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    _doSafeBatchTransferAcceptanceCheck(address,address,address,uint256[],uint256[],bytes)</TD></TR><TR><TD align="left">    _asSingletonArray(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _operatorApprovals</TD></TR><TR><TD align="left">    _uri</TD></TR></TABLE> >];

IERC1155 -> IERC165;
IERC1155[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    balanceOf(address,uint256)</TD></TR><TR><TD align="left">    balanceOfBatch(address[],uint256[])</TD></TR><TR><TD align="left">    setApprovalForAll(address,bool)</TD></TR><TR><TD align="left">    isApprovedForAll(address,address)</TD></TR><TR><TD align="left">    safeTransferFrom(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

IERC1155Receiver -> IERC165;
IERC1155Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC1155Supply -> ERC1155;
ERC1155Supply[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Supply</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply(uint256)</TD></TR><TR><TD align="left">    exists(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _totalSupply</TD></TR></TABLE> >];

IERC1155MetadataURI -> IERC1155;
IERC1155MetadataURI[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155MetadataURI</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uri(uint256)</TD></TR></TABLE> >];

ERC2981 -> IERC2981 [ label="1" ];
ERC2981 -> ERC165 [ label="2" ];
ERC2981[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC2981</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    royaltyInfo(uint256,uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _feeDenominator()</TD></TR><TR><TD align="left">    _setDefaultRoyalty(address,uint96)</TD></TR><TR><TD align="left">    _deleteDefaultRoyalty()</TD></TR><TR><TD align="left">    _setTokenRoyalty(uint256,address,uint96)</TD></TR><TR><TD align="left">    _resetTokenRoyalty(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _defaultRoyaltyInfo</TD></TR><TR><TD align="left">    _tokenRoyaltyInfo</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResultFromTarget(address,bool,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR><TR><TD align="left">    _revert(bytes,string)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

ShortStrings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ShortStrings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toShortString(string)</TD></TR><TR><TD align="left">    toString(ShortString)</TD></TR><TR><TD align="left">    byteLength(ShortString)</TD></TR><TR><TD align="left">    toShortStringWithFallback(string,string)</TD></TR><TR><TD align="left">    toStringWithFallback(ShortString,string)</TD></TR><TR><TD align="left">    byteLengthWithFallback(ShortString,string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _FALLBACK_SENTINEL</TD></TR></TABLE> >];

StorageSlot[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>StorageSlot</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getAddressSlot(bytes32)</TD></TR><TR><TD align="left">    getBooleanSlot(bytes32)</TD></TR><TR><TD align="left">    getBytes32Slot(bytes32)</TD></TR><TR><TD align="left">    getUint256Slot(bytes32)</TD></TR><TR><TD align="left">    getStringSlot(bytes32)</TD></TR><TR><TD align="left">    getStringSlot(string)</TD></TR><TR><TD align="left">    getBytesSlot(bytes32)</TD></TR><TR><TD align="left">    getBytesSlot(bytes)</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toString(int256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left">    toHexString(address)</TD></TR><TR><TD align="left">    equal(string,string)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _SYMBOLS</TD></TR><TR><TD align="left">    _ADDRESS_LENGTH</TD></TR></TABLE> >];

ECDSA[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ECDSA</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _throwError(ECDSA.RecoverError)</TD></TR><TR><TD align="left">    tryRecover(bytes32,bytes)</TD></TR><TR><TD align="left">    recover(bytes32,bytes)</TD></TR><TR><TD align="left">    tryRecover(bytes32,bytes32,bytes32)</TD></TR><TR><TD align="left">    recover(bytes32,bytes32,bytes32)</TD></TR><TR><TD align="left">    tryRecover(bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    recover(bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    toEthSignedMessageHash(bytes32)</TD></TR><TR><TD align="left">    toEthSignedMessageHash(bytes)</TD></TR><TR><TD align="left">    toTypedDataHash(bytes32,bytes32)</TD></TR><TR><TD align="left">    toDataWithIntendedValidatorHash(address,bytes)</TD></TR></TABLE> >];

EIP712 -> IERC5267;
EIP712[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EIP712</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    eip712Domain()</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _domainSeparatorV4()</TD></TR><TR><TD align="left">    _buildDomainSeparator()</TD></TR><TR><TD align="left">    _hashTypedDataV4(bytes32)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _TYPE_HASH</TD></TR><TR><TD align="left">    _cachedDomainSeparator</TD></TR><TR><TD align="left">    _cachedChainId</TD></TR><TR><TD align="left">    _cachedThis</TD></TR><TR><TD align="left">    _hashedName</TD></TR><TR><TD align="left">    _hashedVersion</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _version</TD></TR><TR><TD align="left">    _nameFallback</TD></TR><TR><TD align="left">    _versionFallback</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

Math[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Math</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR><TR><TD align="left">    average(uint256,uint256)</TD></TR><TR><TD align="left">    ceilDiv(uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256,Math.Rounding)</TD></TR><TR><TD align="left">    sqrt(uint256)</TD></TR><TR><TD align="left">    sqrt(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log2(uint256)</TD></TR><TR><TD align="left">    log2(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log10(uint256)</TD></TR><TR><TD align="left">    log10(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log256(uint256)</TD></TR><TR><TD align="left">    log256(uint256,Math.Rounding)</TD></TR></TABLE> >];

SignedMath[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SignedMath</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(int256,int256)</TD></TR><TR><TD align="left">    min(int256,int256)</TD></TR><TR><TD align="left">    average(int256,int256)</TD></TR><TR><TD align="left">    abs(int256)</TD></TR></TABLE> >];

Beacon -> UpgradeableBeacon;
Beacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Beacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deployProxyContract(bytes)</TD></TR></TABLE> >];

ERC1155BeaconProxy -> BeaconProxy;
ERC1155BeaconProxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155BeaconProxy</B></TD></TR></TABLE> >];

ERC1155LazyMint -> IERC1155LazyMint [ label="1" ];
ERC1155LazyMint -> ERC1155Core [ label="2" ];
ERC1155LazyMint -> URIStorage [ label="3" ];
ERC1155LazyMint[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155LazyMint</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    redeem(address,uint256,IERC1155LazyMint.NFTVoucher,bytes)</font></TD></TR><TR><TD align="left">    _verify(IERC1155LazyMint.NFTVoucher,bytes)</TD></TR><TR><TD align="left"><font color="#FFA500">    tokenURI(uint256)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _hash(IERC1155LazyMint.NFTVoucher)</TD></TR><TR><TD align="left"><font color="#FFA500">    _setTokenURI(uint256,string)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _maxSupply</TD></TR></TABLE> >];

ERC1155Singleton -> ERC1155Core [ label="1" ];
ERC1155Singleton -> IMint [ label="2" ];
ERC1155Singleton[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Singleton</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    init(address,string,string,string,uint96)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    mint(address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    mintBatch(address,uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    currentTokenId</TD></TR></TABLE> >];

SingletonFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SingletonFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    deploy(bytes32,bytes)</TD></TR></TABLE> >];

IERC1155Core[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Core</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    init(address,string,string,string,uint96)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR><TR><TD align="left">    version()</TD></TR></TABLE> >];

IERC1155LazyMint[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155LazyMint</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    redeem(address,uint256,IERC1155LazyMint.NFTVoucher,bytes)</TD></TR></TABLE> >];

IMint[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IMint</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    mint(address,uint256,bytes)</TD></TR><TR><TD align="left">    mintBatch(address,uint256[],bytes)</TD></TR></TABLE> >];

ERC1155Core -> IERC1155Core [ label="1" ];
ERC1155Core -> ERC165 [ label="2" ];
ERC1155Core -> ERC1155 [ label="3" ];
ERC1155Core -> EIP712 [ label="4" ];
ERC1155Core -> ERC2981 [ label="5" ];
ERC1155Core -> ERC1155Supply [ label="6" ];
ERC1155Core -> AccessControl [ label="7" ];
ERC1155Core[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1155Core</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    init(address,string,string,string,uint96)</font></TD></TR><TR><TD align="left">    tokenURI(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left">    setContractURI(string)</TD></TR><TR><TD align="left">    setLicenseURI(string)</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isApprovedForAll(address,address)</font></TD></TR><TR><TD align="left">    setDefaultRoyalty(address,uint96)</TD></TR><TR><TD align="left">    feeDenominator()</TD></TR><TR><TD align="left">    deleteDefaultRoyalty()</TD></TR><TR><TD align="left">    setTokenRoyalty(uint256,address,uint96)</TD></TR><TR><TD align="left">    resetTokenRoyalty(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    version()</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _addressToString(address)</TD></TR><TR><TD align="left">    _registerInterface(bytes4)</TD></TR><TR><TD align="left">    _setContractURI(string)</TD></TR><TR><TD align="left">    _setLicenseURI(string)</TD></TR><TR><TD align="left"><font color="#FFA500">    _beforeTokenTransfer(address,address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    contractURI</TD></TR><TR><TD align="left">    licenseURI</TD></TR><TR><TD align="left">    MANAGER_ROLE</TD></TR><TR><TD align="left">    didInit</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _supportedInterfaces</TD></TR></TABLE> >];

URIStorage[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>URIStorage</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    tokenURI(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setTokenURI(uint256,string)</TD></TR><TR><TD align="left">    _getTokenURI(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _tokenURIs</TD></TR></TABLE> >];

MockERC1155SingletonV2 -> ERC1155Singleton;
MockERC1155SingletonV2[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MockERC1155SingletonV2</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    version()</font></TD></TR></TABLE> >];

MockMarketplace -> IERC1155Receiver [ label="1" ];
MockMarketplace -> ERC165 [ label="2" ];
MockMarketplace[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MockMarketplace</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    createListing(address,uint256,uint256,uint256)</TD></TR><TR><TD align="left">    createListingForAllowedUsers(address,uint256,uint256,uint256,address)</TD></TR><TR><TD align="left">    buyListing(uint256)</TD></TR><TR><TD align="left">    buyListingPayRoyalty(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    listings</TD></TR><TR><TD align="left">    nextListingId</TD></TR></TABLE> >];

MockNoPayContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MockNoPayContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    fallback()</TD></TR></TABLE> >];

MockSingletonFactory -> SingletonFactory;
MockSingletonFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>MockSingletonFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    computeAddress(bytes32,bytes)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _computeAddress(bytes32,address,bytes)</TD></TR></TABLE> >];

}